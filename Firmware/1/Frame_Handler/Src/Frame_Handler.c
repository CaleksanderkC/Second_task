/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     29/10/2023 12:22:42
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "stm32g4xx_hal.h"
#include "Frame_Handler.h"
#include "stdbool.h"
#include "stdlib.h"


/* Defines ------------------------------------------------------------------*/
// znak początku ramki
#define FRAME_START_BYTE 0x3C


/* Variables ------------------------------------------------------------------*/
// Elementy ramki
static bool frame_start;
static bool frame_end;
static uint8_t id;
static uint8_t len;
static uint8_t *payload;
static uint8_t it;


// struktura powiązuje id z funkcją zwrotną
typedef struct {
	uint8_t ID;
	void (*fun)(uint8_t len, uint8_t* payload);
}frame_callback;


// tablica opisuje wszystkie obsługiwane ramki
static const frame_callback framesCallback[] = {
		{ 0x11, *motor_set_mode},
		{ 0x12, *motor_set_speed},
		{ 0x13, *motor_set_pos},
};


/** Functions ----------------------------------------------------------------*/
void SEQUENCE_Handler(void);


void motor_set_mode(uint8_t len, uint8_t* payload)
{
	return;
}

void motor_set_speed(uint8_t len, uint8_t* payload)
{
	return;
}

void motor_set_pos(uint8_t len, uint8_t* payload)
{
	return;
}


void init_new_frame(void)
{
	frame_start = 0;
	frame_end = 0;
	id = 0;
	len = 0;
	it = 0;
	free(payload);
}



void frame_end_process(void)
{
	for(int i=0; i < sizeof(framesCallback)/sizeof(frame_callback); ++i)
	{
		// wywołanie odpowiedniej funkci zwrotnej
		if(id == framesCallback[i].ID)
			(*framesCallback[i].fun) (len, payload);
	}

	init_new_frame();
}

void frame_process(uint8_t value)
{
	// początek inicjalizacji ramki
	if(frame_start == 0)
	{
		if(value == FRAME_START_BYTE)
		{
			frame_start = 1;
		}
		else
		{
			// Przypadek otrzymania niepoprawnwgo znaku startu
			SEQUENCE_Handler();
		}
	}
	else
	{
		// inicjalizacja parametrów id, len, rozmiar payload
		if(id == 0)
		{
			id = value;
		}
		else if(len == 0)
		{
			len = value;
			payload = (uint8_t*) malloc(len * sizeof(uint8_t));
		}
		// inicjalizacja tablicy danych payload
		else
		{
			payload[it++] = value;
			if(it >= len) frame_end = 1;
		}
	}

	// koniec inicjalizacji ramki
	if(frame_end == true)
	{
		frame_end_process();
	}
}


HAL_StatusTypeDef FRAME_HANDLER_HAL_UART_Receive(UART_HandleTypeDef *huart, uint32_t Timeout)
{
	uint8_t value;

	//sprawdzenie otrzymanego bajtu danych
	HAL_StatusTypeDef St = HAL_UART_Receive(huart, &value, 1, Timeout);
	if (St == HAL_OK) frame_process(value);
	return St;
}


void SEQUENCE_Handler(void)
{

}



